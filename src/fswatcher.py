# Copyright (C) 2010 Sebastian Ruml <sebastian.ruml@gmail.com>## This file is part of the PythonDrop project## This program is free software; you can redistribute it and/or modify# it under the terms of the GNU General Public License as published by# the Free Software Foundation; either version 1, or (at your option)# any later version.## This program is distributed in the hope that it will be useful,# but WITHOUT ANY WARRANTY; without even the implied warranty of# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the# GNU General Public License for more details.## You should have received a copy of the GNU General Public License# along with this program; if not, write to the Free Software# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.import osimport timefrom git import *#import gitimport logclass FSWatcher:	def __init__(self, config):		self._logger = log.Logger()		self._config = config		self._run = True		self._checking = True				if not self._config['sync_interval']:			self._config['sync_interval'] = 10					self._interval = self._config['sync_interval']					if not self._config['pythondrop_folder']:			# TODO: Set default sync folder: $HOME + PythonDrop			pass				self.initRepository()				def initRepository(self):		# Check if the synchronization folder exits		path = str(self._config['pythondrop_folder'])		if not os.path.exists(path):			os.mkdir(path)					# Check if the user has already a GIT repository. If not, create one.		os.chdir(path)		if not os.path.exists(".git"):			self._logger.info("Creating new Git repository")			self._repo = Repo.init(".", bare=False)			assert self._repo.bare == False						self._logger.info("Adding remote to Git repository")			self._git = Git('.')						# Define remote repository shorthand			remote_rep_url = self._config['remote_user'] + "@" + self._config['remote_host'] + ":" + self._config['remote_repository_path']			self._git_remote = self._repo.create_remote('origin', remote_rep_url)		else:			self._logger.info("Opening existing Git repository")			self._repo = Repo(".")			self._git = Git('.')						remotes = self._repo.remotes			self._git_remote = remotes[0]		def get_updateInterval(self):		return self._interval		def set_updateInterval(self, value):		self._interval = value;		updateInterval = property(get_updateInterval, set_updateInterval)		def watch(self):		remote_check = True		cleanup_counter = 0					os.chdir(str(self._config['pythondrop_folder']))				while self._run:			if self._checking:				# Check the remote repository				if remote_check:					self._logger.info("Start checking remote repository")										try:						remote_head = self._git.ls_remote('origin', 'HEAD')												if remote_head:							remote_head = remote_head.split('\t')[0]							self._logger.debug("Remote head: " + remote_head)													try:							local_head = self._git.rev_parse('HEAD')							self._logger.debug("Local head: " + local_head)						except:							local_head = ''												if remote_head != local_head:							self._logger.info("Updating from remote repository...")							self._git.reset('--hard', 'HEAD')							self._git.pull('origin', 'master')							self._logger.info("Update from remote repository finished.")						else:							self._logger.info("Remote and local repository are in sync.")					except:						self._logger.info("Error checking remote repository!")											remote_check = False					self._logger.info("End checking remote repository")				else:					remote_check = True								# Checking local folder				self._logger.info("Start checking local folder")								add_count = 0				change_count = 0								# Check for added, untracked, modified and deleted files				index = self._repo.index				untracked_files = self._repo.untracked_files				wdiff = index.diff(None)								# Added files				for diff_added in wdiff.iter_change_type('A'):					self._logger.info("Added: " + diff_added.a_blob.name)					change_count += 1								# Modified files				for diff_modified in wdiff.iter_change_type('M'):					self._logger.info("Modified: " + diff_modified.a_blob.name)					change_count += 1								# Deleted files				for diff_deleted in wdiff.iter_change_type('D'):					self._logger.info("Deleted: " + diff_deleted.a_blob.name)					change_count += 1												# Untracked files				for file in untracked_files:					self._logger.info("Untracked: " + file)					add_count += 1					change_count += 1								# Add untracked files to the repository				if add_count > 0:					self._logger.info("Adding " + str(add_count) + " new file(s)")					index.add(untracked_files)									# Commit all changes				if change_count > 0:					self._logger.info(str(change_count) + " file(s) changed. Start comitting...")					commit_message = "'" + str(change_count) + " file(s) updated" + "'"					try:						self._git.commit('-a', '-m', commit_message)					except:						self._logger.info("Warning: Commit failed!")											#if index.commit(str(change_count) + " file(s) updated"):					#	self._logger.info("All files are comitted.")					#else:					#	self._logger.info("Error committing files!")										# If any changes; push it to the remote repository				if change_count == 0 and add_count == 0:					self._logger.info("No changes")				else:					self._logger.info("Pushing all changes to the remote repository...")					try:						self._git.push('origin', 'master')					except:						self._logger.info("Warning: GIT push failed!")					self._logger.info("Git push finished")										# Git repository cleanup					if cleanup_counter > 10:						self._logger.info("Cleaning up GIT repository")						self._git.gc('--auto')						cleanup_counter = 0						self._logger.info("Cleaning finished")					else:						cleanup_counter += 1									self._logger.info("End checking local folder")							# Sleep for the given time			time.sleep(self._interval)		def start(self):		"""		Starts watching the repository.		"""		self._checking = True		def stop(self):		"""		Stops watching the repository		"""		self._checking = False